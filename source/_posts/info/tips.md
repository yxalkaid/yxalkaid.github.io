---
title: tips
date: 2025-03-15
categories: 

tags: 

# 摘要
excerpt: false
---

## MySQL
### 优化
- 怎样定位慢查询？
    - 运维工具，如Skywalking等
    - MySQL提供的慢查询日志

- 如何分析一个执行很慢的SQL语句？
使用`EXPLAIN`关键字。例如：`EXPLAIN SELECT * FROM user WHERE id = 1;`
    - type
    - possible_keys
    - key
    - key_len

- 索引
    - 索引是MySQL为表创建的数据结构，用于高效查找数据。
    - 提高数据检索的效率，减低数据库的IO成本。
    - 通过索引列队数据进行排序，降低了数据排序的成本。

- 索引的底层数据结构
MySQL的InnoDB引擎使用B+树作为索引的底层数据结构。
    - 阶数更多，层数更小。
    - 非叶子结点只存储指针，叶子结点存储数据，磁盘读写代价更低。
    - 叶子结点是一个有序的双向连链表，便于全表扫描和区间查询。

- 聚簇索引和非聚簇索引（二级索引）
    - 聚簇索引：有且只有一个。索引和数据存储在一起，索引结构的叶子结点保存了行数据。
        - 主键、唯一索引、隐含的行号。
    - 非聚簇索引：可以存在多个。索引结构与数据分开存储，索引结构的叶子节点保存的是对应的主键。

- 回表查询
通过非聚簇索引查询主键值，然后通过聚簇索引查询整行数据。

- 覆盖索引
查询时使用了索引，并且需要返回的列在该索引中已经全部能够找到。

- 超大分页怎么处理？
在数据量很大时，使用limit进行分页会存在性能问题。可以通过覆盖索引获取目标数据的id，然后子查询过滤出目标数据。

- 索引的创建原则
    - 数据量大，且查询比较频繁的表
    - 常用作查询条件、排序、分组的字段
    - 字段内容的区分度高
    - 内容较长时，可以使用前缀索引
    - 尽量使用联合索引
    - 要控制索引的数量
    - 注意NULL值

- 索引失效
    - 违反最左前缀法则
    - 范围查询右边的列，索引失效
    - 对索引列进行运算操作，索引失效
    - 字符串不加单引号，发生类型转换，造成索引失效
    - 以%开头的LIKE模糊查询，索引失效

- SQL优化
    - 表的设计优化
        - 选择合适的数据类型
    - 索引优化
    - SQL语句的优化
        - 指明字段名称，尽量避免直接使用`SELECT *`
        - 尽量避免索引失效的写法
        - 尽量用`union all`（不去除重复）代替`union`（去除重复）。
        - 避免在where子句对字段进行表达式操作
        - 连接时，尽量使用内连接`inner join`。
        - 连接时，优先把小表放在外边。
    - 主从复制、读写分离
    - 分库分表
        - 数据量很大时，使用分库分表。

### 事务
- 事务的特性
    - 原子性（atomicity）：一个事务中的所有操作，要么都成功，要么都失败。
    - 一致性（consistency）：事务完成前后，数据库都保持一致的状态。
    - 隔离性（isolation）：并发执行的各个事务之间不会相互影响。
    - 持久性（durability）：事务一旦提交或回滚，对数据库的修改就是永久的。

- 并发事务带来的问题
    - 脏读：一个事务读取了另一个事务未提交的数据。
    - 不可重复读：一个事务先后读取同一条数据，结果不一致。
    - 幻读：一个事务查询某条数据时，没有对应的数据行。但是插入数据时，又发现这条数据已经存在。

- 隔离的级别
    - 读未提交：允许脏读、不可重复读、幻读。
    - 读已提交：允许不可重复读、幻读。
    - 可重复读：允许幻读。（MySQL默认的隔离级别）
    - 串行化：不允许脏读、不可重复读、幻读。

- `undo log`和`redo log`的区别
    - `undo log`重做日志：记录了事务提交时对数据页的物理修改，用来实现事务的持久性。
    - `redo log`回滚日志：记录了数据被修改的信息，提供回滚和MVCC（多版本并发控制），保证事务的原则性和一致性。

- 如何保证事务的隔离性
    - 锁
        - 共享锁
        - 排它锁
    - MVCC（多版本并发控制）

- MySQL的主从同步原理
    - 二进制日志Binlog：记录了数据库的修改信息（DDL、DML）。
    - 复制步骤：
        1. 主库输出线程：主库在事务提交时，会将数据变更记录在二进制日志中。
        2. 从库IO线程：从库读取主库的二进制日志文件，写入到从库的中继日志中`Relay log`。
        3. 从库SQL线程：从库重做中继日志，将数据变更应用到从库上。、

- MySQL的日志
<!-- TODO -->

- 分库分表
    - 垂直分库：以表为依据，根据业务将不同表拆分到不同库中
    高并发下提高磁盘IO和网络连接数
    - 垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中
    冷热数据分离，多表互不影响
        - 将不常用的字段单独放在一张表
        - 将大字段拆分到一张表中
    - 水平分库：将一个库的数据拆分到多个库中
    解决海量数据存储和高并发问题
    - 水平分表：将一个表的数据拆分到多个表中
    解决单表存储和性能问题

- 分库带来的问题
使用中间件mycat等
    - 分布式事务一致性问题
    - 跨节点关联查询
    - 跨节点分页、排序
    - 主键唯一性问题

## Java集合
### 集合
List
    - Vector（线程安全）
    - ArrayList（非线程安全，数组结构）
    - LinkedList（非线程安全，双向链表结构）

Set
    - HashSet（哈希表结构）
    - TreeSet（红黑树结构）

Map
    - HashMap（非线程安全，哈希表结构）
    - CurrentHashMap（线程安全，哈希表结构）
    - TreeMap（红黑树结构）

### ArrayList
未指定初始化大小时，第一次扩容为默认大小10，之后每次扩容为原来的1.5倍。

### Array和List之间的转换
- Array转为List
    - Arrays.asList(array)
    - 未进行数组的复制。修改list中的元素，会影响数组中的元素。
- List转为Array
    - list.toArray()
    - 进行了数组的浅复制。修改list中的元素，不会影响数组中的元素。

### 红黑树
- 树的节点要么是红色，要么是黑色。
- 根节点是黑色。
- 叶子结点都是黑色的空节点。
- 红色节点的子节点都是黑色节点。（红色节点不能连续）
- 从任一节点到叶子结点的所有路径都包含相同数目的黑色节点。

### HashMap
- 默认初始化大小为16。存储的键值对数量超过阈值时进行扩容，每次扩容为原来的2倍。
- 数组的长度为2的n次幂。插入或扩容时计算下标的效率更高。
- hash值相同的key，则存储在同一个桶中，桶中使用链表或红黑树存储。
- 寻址算法：
    1. 调用对象的hashCode()方法，得到hash值。
    2. 使用hash()进行二次哈希，让哈希值分布更均匀。
    3. 计算`hash&(capacity-1)`，得到数组下标。
- java1.7多线程死循环问题
    - 使用头插法进行扩容
    - 线程1和线程2同时准备扩容


### concurrentHashMap
- jdk1.7中
    - 使用分段的数组+链表实现。
    - 采用Segment分段加锁，底层使用ReentrantLock。
- jdk1.8
    - 与HashMap1.8的结构相同，使用数组、链表或红黑树实现。
    - 采用CAS添加新节点。
    - 采用synchronized锁住链表的首节点或红黑树的根节点。


## 多线程
### 线程
- 进程与线程
进程包含了线程。线程的上下文切换成本比进程的低。
不同进程使用不同的内存空间，同一个进程下的所有线程共享内存空间。

- 并行与并发
并行：同一时间内多个任务同时进行。
并发：同一时间内多个任务交替进行。

- 创建线程的方式
    - 继承Thread类
    - 实现Runnable接口
        - 实现run()方法，无返回值。
        - 不能抛出异常（检查型异常）。
    - 实现Callable接口
        - 实现call()方法，有返回值。
        - 配合FutureTask使用。
        - 可以抛出异常。
    - 使用线程池

- 线程状态
    - 新建
    - 就绪
    - 运行
    - 阻塞：等待资源、等待信号、等待IO操作完成。
    - 等待：线程调用wait()方法。
    - 睡眠：线程调用sleep()方法。
    - 终止

- notify和notifyAll的区别
    - notify：随机唤醒一个正在等待的线程。
    - notifyAll：唤醒所有正在等待的线程。

- wait和sleep的区别
    - wait
        - Object的成员方法。
        - 需要先获得wait对象的锁。
        - 执行后会释放锁。
    - sleep
        - Thread的静态方法。
        - 不需要获得锁。
        - 不释放锁。

- 如果停止一个正在运行的线程？
interrupt()方法
    - 如果线程处于阻塞状态，则抛出InterruptedException异常。
    - 如果线程处于运行状态，则设置中断标志。

- synchronized关键字的底层原理
    - 由Monitor实现，实现的锁属于重量级锁。
    - Monitor结构
        - WaitSet：关联了调用了wait()方法的线程。
        - EntryList：关联了调用了synchronized代码块的线程（没有持有锁的线程）
        - Owner：当前持有锁的线程。
    - 锁升级：对象头中的MarkWord部分
        - 偏向锁
        - 轻量级锁
        - 重量级锁：使用Monitor实现，性能较低。

- JMM（Java内存模型）
JMM将内存分为主内存和工作内存。线程与线程之间是隔离的，交互需要通过主内存。

- CAS
CAS（比较再交换），体现的是乐观锁的实现，在无锁状态下保证线程操作数据的原子性。

- volatile
    - 禁止JIT对volatile修饰的变量进行优化，让一个线程对共享变量的修改对另一个线程可见
    - 禁止指令重排

- AQS
AQS（抽象队列同步器）是多线程中的队列同步器，是一种锁机制，作为一个基础框架使用，ReentrantLock通过AQS实现。
内部维护了一个先进先出的双向队列，存储的是排队的线程。
对state属性进行CAS操作，保证线程操作数据的原子性。

- ReentrantLock
主要使用CAS和AQS实现，默认为非公平锁。
特点：可中断、可以设置超时、可以设置公平锁、支持多个条件变量、支持重入。

- synchronized和Lock的区别
    - synchronized
        - 关键字，源码jvm中，使用C++实现
        - 自动释放
        - 悲观锁、互斥、同步、可重入
    - Lock
        - 接口，源码在jdk中，使用Java实现
        - 需要手动释放
        - 悲观锁、互斥、同步、可重入
        - 提供公平锁、可打断、可超时、多条件变量

- 死锁的产生条件
    - 互斥、不剥夺、请求和保持、循环等待
    - 死锁诊断：jps、jstack

- 怎么保证多线程的执行安全？
    - 原子性：synchronized、Lock
    - 内存可见性：volatile、synchronized、Lock
    - 有序性：volatile

### 线程池
- 线程池的作用
线程池可以减少频繁的创建线程和销毁线程带来的性能损耗。

- 线程池的核心参数
    - corePoolSize：核心线程数。
    - maximumPoolSize：最大线程数。
    - keepAliveTime：线程空闲时间。

- 线程池的执行原理
    - 线程池创建时，创建corePoolSize个线程。
    - 如果核心线程已满，添加到任务队列中。
    - 如果任务队列已满，创建非核心线程。
    - 如果总线程数超过maximumPoolSize，则执行拒绝策略。
        - AbortPolicy：直接抛出异常。(默认策略)
        - DiscardPolicy：直接丢弃。
        - DiscardOldestPolicy：丢弃队列中最旧的任务。
        - CallerRunsPolicy：由调用者线程处理该任务。

- 线程池的阻塞队列
    - ArrayBlockingQueue：基于数组的先进先出队列。
        - 强制有界
        - 提前初始化
        - 使用一个锁
    - LinkedBlockingQueue：基于链表的先进先出队列。
        - 无界，可以有界。
        - 插入时初始化
        - 首尾共两个锁
    - SynchronousQueue：

- 如何确定核心线程数？
    - 高并发、任务执行时间短
        - 核心线程数：N+1。减少线程上下文切换
    - IO密集型
        - 核心线程数：2N+1
    - CPU密集型
        - 核心线程数：N+1

- 线程池的种类
Executors类的静态函数。不建议使用，因为等待队列长度默认为`Integer.MAX_VALUE`，可能会堆积大量请求，导致内存溢出。
    - newFixedThreadPool：固定大小线程池。
    - newSingleThreadExecutor：单线程线程池。
    - newCachedThreadPool：可变大小线程池。
    - newScheduledThreadPool：定时线程池。

- 线程池的使用场景
    - 批量导入
    - 数据汇总
        - 多线程获取不同数据
    - 异步任务
        - 统计数据
        - 保存日志

- CountDownLatch
    - 设置目标数量，主线程调用await()方法，等待其他线程。
    - 其他线程执行完，调用countDown()方法。
    - 数量为0时，主线程继续执行。
    - 不可重复使用。

- CyclicBarrier
    - 设置目标数量。
    - 其他线程执行到某个阶段，调用await()方法，等待其他线程。
    - 数量到达目标数量时，等待的线程继续执行。
    - 可以重复使用。

- semaphore信号量
    - acquire()
    - release()

- ThreadLocal
    - 线程内部存储类，实现资源对象的线程隔离，避免线程争用引发的安全问题。
    - 每个线程维持一个ThreadLocalMap对象，以ThreadLocal对象为key，保存数据。
    - 内存泄露问题：ThreadLocalMap中的key是对ThreadLocal的弱引用。而value是强引用，若为调用remove()，不会被GC回收。

### 锁的类型
- 乐观锁和悲观锁
- 公平锁和非公平锁
- 互斥锁和共享锁
- 可重入锁和非可重入锁
- 自旋锁、分段锁、死锁

## Redis
- 使用场景
    - 缓存
        - 穿透、击穿、雪崩
        - 双写一致性、持久化
        - 数据过期、淘汰策略
    - 分布式锁
        - setnx、redisson
    - 计数器
    - 保存token
    - 消息队列
    - 延迟队列

- 布隆过滤器
    - 多个独立的哈希函数
    - 数组越大，误判率越小，内存消耗越高。

- 缓存穿透
查询不存在的数据时，数据库查询不到也不直接写入缓存，导致每次请求都查询数据库。
    - 缓存空数据
    - 布隆过滤器
        - 预热缓存时，同时预热布隆过滤器。
        - 访问缓存前，先经过布隆过滤器判断。
        - 实现复杂，存在误判

- 缓存击穿
当某一个缓存数据过期时，需要查询数据库，重建缓存。
在重建缓存期间，大量对该数据请求由于缓存未命中而直接访问数据库。
    - 互斥锁：强一致，性能差
        1. 查询缓存，若命中，则直接返回。
        2. 若未命中，先获取互斥锁，再查询数据库，重建缓存。
        3. 若获取锁失败，则重试第1步和第2步。
    - 逻辑过期：高可用，性能高
        0. 不设置过期时间，在缓存数据中设置逻辑过期时间。
        1. 查询缓存，若数据未过期，则直接返回。
        2. 若数据过期，先获取互斥锁，再开启一个用于查询数据库、重建缓存的新线程，最后直接返回旧缓存数据。
        3. 若获取锁失败，直接返回旧缓存数据。

- 缓存雪崩
同一时段大量的缓存数据同时失效或Redis服务宕机，导致大量请求访问数据库。
    - 给不同key的TTL添加随机值
    - 使用多级缓存
    - 使用Redis集群：哨兵模式、集群模式
    - 添加降级限流策略

- 双写一致性
当修改了数据库的数据后，也要同时更新缓存的数据，保持缓存和数据库的数据一致。
    - 延时双删
        - 写操作时，先删除缓存数据，再修改数据库，延时后删除缓存数据
        - 缺点：延时的时长难以控制。
    - 一致性要求高时
        - 使用redisson提供的读写锁
    - 允许延时一致时：采用异步通知
        - 使用MQ中间件，更新数据后，通知删除缓存。
        - 使用canal中间件，读取数据库的binlog，更新缓存。

- Redis持久化
RDB（Redis数据备份文件）
    - 主动备份
        - save（主线程执行RDB）、bgsave（子线程执行RDB）

## 分布式
### Paxos算法




