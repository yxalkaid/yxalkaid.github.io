---
title: tips
date: 2025-03-15
categories: 

tags: 

# 摘要
excerpt: false
---

## MySQL
### 优化
- 怎样定位慢查询？
    - 运维工具，如Skywalking等
    - MySQL提供的慢查询日志

- 如何分析一个执行很慢的SQL语句？
使用`EXPLAIN`关键字。例如：`EXPLAIN SELECT * FROM user WHERE id = 1;`
    - type
    - possible_keys
    - key
    - key_len

- 索引
    - 索引是MySQL为表创建的数据结构，用于高效查找数据。
    - 提高数据检索的效率，减低数据库的IO成本。
    - 通过索引列队数据进行排序，降低了数据排序的成本。

- 索引的底层数据结构
MySQL的InnoDB引擎使用B+树作为索引的底层数据结构。
    - 阶数更多，层数更小。
    - 非叶子结点只存储指针，叶子结点存储数据，磁盘读写代价更低。
    - 叶子结点是一个有序的双向连链表，便于全表扫描和区间查询。

- 聚簇索引和非聚簇索引（二级索引）
    - 聚簇索引：有且只有一个。索引和数据存储在一起，索引结构的叶子结点保存了行数据。
        - 主键、唯一索引、隐含的行号。
    - 非聚簇索引：可以存在多个。索引结构与数据分开存储，索引结构的叶子节点保存的是对应的主键。

- 回表查询
通过非聚簇索引查询主键值，然后通过聚簇索引查询整行数据。

- 覆盖索引
查询时使用了索引，并且需要返回的列在该索引中已经全部能够找到。

- 超大分页怎么处理？
在数据量很大时，使用limit进行分页会存在性能问题。可以通过覆盖索引获取目标数据的id，然后子查询过滤出目标数据。

- 索引的创建原则
    - 数据量大，且查询比较频繁的表
    - 常用作查询条件、排序、分组的字段
    - 字段内容的区分度高
    - 内容较长时，可以使用前缀索引
    - 尽量使用联合索引
    - 要控制索引的数量
    - 注意NULL值

- 索引失效
    - 违反最左前缀法则
    - 范围查询右边的列，索引失效
    - 对索引列进行运算操作，索引失效
    - 字符串不加单引号，发生类型转换，造成索引失效
    - 以%开头的LIKE模糊查询，索引失效

- SQL优化
    - 表的设计优化
        - 选择合适的数据类型
    - 索引优化
    - SQL语句的优化
        - 指明字段名称，尽量避免直接使用`SELECT *`
        - 尽量避免索引失效的写法
        - 尽量用`union all`（不去除重复）代替`union`（去除重复）。
        - 避免在where子句对字段进行表达式操作
        - 连接时，尽量使用内连接`inner join`。
        - 连接时，优先把小表放在外边。
    - 主从复制、读写分离
    - 分库分表
        - 数据量很大时，使用分库分表。

### 事务
- 事务的特性
    - 原子性（atomicity）：一个事务中的所有操作，要么都成功，要么都失败。
    - 一致性（consistency）：事务完成前后，数据库都保持一致的状态。
    - 隔离性（isolation）：并发执行的各个事务之间不会相互影响。
    - 持久性（durability）：事务一旦提交或回滚，对数据库的修改就是永久的。

- 并发事务带来的问题
    - 脏读：一个事务读取了另一个事务未提交的数据。
    - 不可重复读：一个事务先后读取同一条数据，结果不一致。
    - 幻读：一个事务查询某条数据时，没有对应的数据行。但是插入数据时，又发现这条数据已经存在。

- 隔离的级别
    - 读未提交：允许脏读、不可重复读、幻读。
    - 读已提交：允许不可重复读、幻读。
    - 可重复读：允许幻读。（MySQL默认的隔离级别）
    - 串行化：不允许脏读、不可重复读、幻读。

- `undo log`和`redo log`的区别
    - `undo log`重做日志：记录了事务提交时对数据页的物理修改，用来实现事务的持久性。
    - `redo log`回滚日志：记录了数据被修改的信息，提供回滚和MVCC（多版本并发控制），保证事务的原则性和一致性。

- 如何保证事务的隔离性
    - 锁
        - 共享锁
        - 排它锁
    - MVCC（多版本并发控制）

- MySQL的主从同步原理
    - 二进制日志Binlog：记录了数据库的修改信息（DDL、DML）。
    - 复制步骤：
        1. 主库输出线程：主库在事务提交时，会将数据变更记录在二进制日志中。
        2. 从库IO线程：从库读取主库的二进制日志文件，写入到从库的中继日志中`Relay log`。
        3. 从库SQL线程：从库重做中继日志，将数据变更应用到从库上。、

- MySQL的日志
<!-- TODO -->

- 分库分表
    - 垂直分库：以表为依据，根据业务将不同表拆分到不同库中
    高并发下提高磁盘IO和网络连接数
    - 垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中
    冷热数据分离，多表互不影响
        - 将不常用的字段单独放在一张表
        - 将大字段拆分到一张表中
    - 水平分库：将一个库的数据拆分到多个库中
    解决海量数据存储和高并发问题
    - 水平分表：将一个表的数据拆分到多个表中
    解决单表存储和性能问题

- 分库带来的问题
使用中间件mycat等
    - 分布式事务一致性问题
    - 跨节点关联查询
    - 跨节点分页、排序
    - 主键唯一性问题

## Java集合
### 集合
List
    - Vector（线程安全）
    - ArrayList（非线程安全，数组结构）
    - LinkedList（非线程安全，双向链表结构）

Set
    - HashSet（哈希表结构）
    - TreeSet（红黑树结构）

Map
    - HashMap（非线程安全，哈希表结构）
    - CurrentHashMap（线程安全，哈希表结构）
    - TreeMap（红黑树结构）

### ArrayList
未指定初始化大小时，第一次扩容为默认大小10，之后每次扩容为原来的1.5倍。

### Array和List之间的转换
- Array转为List
    - Arrays.asList(array)
    - 未进行数组的复制。修改list中的元素，会影响数组中的元素。
- List转为Array
    - list.toArray()
    - 进行了数组的浅复制。修改list中的元素，不会影响数组中的元素。

### 红黑树
- 树的节点要么是红色，要么是黑色。
- 根节点是黑色。
- 叶子结点都是黑色的空节点。
- 红色节点的子节点都是黑色节点。（红色节点不能连续）
- 从任一节点到叶子结点的所有路径都包含相同数目的黑色节点。

### HashMap
- 默认初始化大小为16。存储的键值对数量超过阈值时进行扩容，每次扩容为原来的2倍。
- 数组的长度为2的n次幂。插入或扩容时计算下标的效率更高。
- hash值相同的key，则存储在同一个桶中，桶中使用链表或红黑树存储。
- 寻址算法：
    1. 调用对象的hashCode()方法，得到hash值。
    2. 使用hash()进行二次哈希，让哈希值分布更均匀。
    3. 计算`hash&(capacity-1)`，得到数组下标。
- java1.7多线程死循环问题
    - 使用头插法进行扩容
    - 线程1和线程2同时准备扩容


### concurrentHashMap
- jdk1.7中
    - 使用分段的数组+链表实现。
    - 采用Segment分段加锁，底层使用ReentrantLock。
- jdk1.8
    - 与HashMap1.8的结构相同，使用数组、链表或红黑树实现。
    - 采用CAS添加新节点。
    - 采用synchronized锁住链表的首节点或红黑树的根节点。


## 多线程
### 线程
- 进程与线程
进程包含了线程。线程的上下文切换成本比进程的低。
不同进程使用不同的内存空间，同一个进程下的所有线程共享内存空间。

- 并行与并发
并行：同一时间内多个任务同时进行。
并发：同一时间内多个任务交替进行。

- 创建线程的方式
    - 继承Thread类
    - 实现Runnable接口
        - 实现run()方法，无返回值。
        - 不能抛出异常（检查型异常）。
    - 实现Callable接口
        - 实现call()方法，有返回值。
        - 配合FutureTask使用。
        - 可以抛出异常。
    - 使用线程池

- 线程状态
    - 新建
    - 就绪
    - 运行
    - 阻塞：等待资源、等待信号、等待IO操作完成。
    - 等待：线程调用wait()方法。
    - 睡眠：线程调用sleep()方法。
    - 终止

- notify和notifyAll的区别
    - notify：随机唤醒一个正在等待的线程。
    - notifyAll：唤醒所有正在等待的线程。

- wait和sleep的区别
    - wait
        - Object的成员方法。
        - 需要先获得wait对象的锁。
        - 执行后会释放锁。
    - sleep
        - Thread的静态方法。
        - 不需要获得锁。
        - 不释放锁。

- 如果停止一个正在运行的线程？
interrupt()方法
    - 如果线程处于阻塞状态，则抛出InterruptedException异常。
    - 如果线程处于运行状态，则设置中断标志。

- synchronized关键字的底层原理
    - 由Monitor实现，实现的锁属于重量级锁。
    - Monitor结构
        - WaitSet：关联了调用了wait()方法的线程。
        - EntryList：关联了调用了synchronized代码块的线程（没有持有锁的线程）
        - Owner：当前持有锁的线程。
    - 锁升级：对象头中的MarkWord部分
        - 偏向锁
        - 轻量级锁
        - 重量级锁：使用Monitor实现，性能较低。

- JMM（Java内存模型）
JMM将内存分为主内存和工作内存。线程与线程之间是隔离的，交互需要通过主内存。

- CAS
CAS（比较再交换），体现的是乐观锁的实现，在无锁状态下保证线程操作数据的原子性。

- volatile
    - 禁止JIT对volatile修饰的变量进行优化，让一个线程对共享变量的修改对另一个线程可见
    - 禁止指令重排

- AQS
AQS（抽象队列同步器）是多线程中的队列同步器，是一种锁机制，作为一个基础框架使用，ReentrantLock通过AQS实现。
内部维护了一个先进先出的双向队列，存储的是排队的线程。
对state属性进行CAS操作，保证线程操作数据的原子性。

- ReentrantLock
主要使用CAS和AQS实现，默认为非公平锁。
特点：可中断、可以设置超时、可以设置公平锁、支持多个条件变量、支持重入。

- synchronized和Lock的区别
    - synchronized
        - 关键字，源码jvm中，使用C++实现
        - 自动释放
        - 悲观锁、互斥、同步、可重入
    - Lock
        - 接口，源码在jdk中，使用Java实现
        - 需要手动释放
        - 悲观锁、互斥、同步、可重入
        - 提供公平锁、可打断、可超时、多条件变量

- 死锁的产生条件
    - 互斥、不剥夺、请求和保持、循环等待
    - 死锁诊断：jps、jstack

- 怎么保证多线程的执行安全？
    - 原子性：synchronized、Lock
    - 内存可见性：volatile、synchronized、Lock
    - 有序性：volatile

### 线程池
- 线程池的作用
线程池可以减少频繁的创建线程和销毁线程带来的性能损耗。

- 线程池的核心参数
    - corePoolSize：核心线程数。
    - maximumPoolSize：最大线程数。
    - keepAliveTime：线程空闲时间。

- 线程池的执行原理
    - 线程池创建时，创建corePoolSize个线程。
    - 如果核心线程已满，添加到任务队列中。
    - 如果任务队列已满，创建非核心线程。
    - 如果总线程数超过maximumPoolSize，则执行拒绝策略。
        - AbortPolicy：直接抛出异常。(默认策略)
        - DiscardPolicy：直接丢弃。
        - DiscardOldestPolicy：丢弃队列中最旧的任务。
        - CallerRunsPolicy：由调用者线程处理该任务。

- 线程池的阻塞队列
    - ArrayBlockingQueue：基于数组的先进先出队列。
        - 强制有界
        - 提前初始化
        - 使用一个锁
    - LinkedBlockingQueue：基于链表的先进先出队列。
        - 无界，可以有界。
        - 插入时初始化
        - 首尾共两个锁
    - SynchronousQueue：

- 如何确定核心线程数？
    - 高并发、任务执行时间短
        - 核心线程数：N+1。减少线程上下文切换
    - IO密集型
        - 核心线程数：2N+1
    - CPU密集型
        - 核心线程数：N+1

- 线程池的种类
Executors类的静态函数。不建议使用，因为等待队列长度默认为`Integer.MAX_VALUE`，可能会堆积大量请求，导致内存溢出。
    - newFixedThreadPool：固定大小线程池。
    - newSingleThreadExecutor：单线程线程池。
    - newCachedThreadPool：可变大小线程池。
    - newScheduledThreadPool：定时线程池。

- 线程池的使用场景
    - 批量导入
    - 数据汇总
        - 多线程获取不同数据
    - 异步任务
        - 统计数据
        - 保存日志

- CountDownLatch
    - 设置目标数量，主线程调用await()方法，等待其他线程。
    - 其他线程执行完，调用countDown()方法。
    - 数量为0时，主线程继续执行。
    - 不可重复使用。

- CyclicBarrier
    - 设置目标数量。
    - 其他线程执行到某个阶段，调用await()方法，等待其他线程。
    - 数量到达目标数量时，等待的线程继续执行。
    - 可以重复使用。

- semaphore信号量
    - acquire()
    - release()

- ThreadLocal
    - 线程内部存储类，实现资源对象的线程隔离，避免线程争用引发的安全问题。
    - 每个线程维持一个ThreadLocalMap对象，以ThreadLocal对象为key，保存数据。
    - 内存泄露问题：ThreadLocalMap中的key是对ThreadLocal的弱引用。而value是强引用，若为调用remove()，不会被GC回收。

### 锁的类型
- 乐观锁和悲观锁
- 公平锁和非公平锁
- 互斥锁和共享锁
- 可重入锁和非可重入锁
- 自旋锁、分段锁、死锁

## Redis
- 使用场景
    - 缓存
        - 穿透、击穿、雪崩
        - 双写一致性、持久化
        - 数据过期、淘汰策略
    - 分布式锁
        - setnx、redisson
    - 计数器
    - 保存token
    - 消息队列
    - 延迟队列

- 布隆过滤器
    - 多个独立的哈希函数
    - 数组越大，误判率越小，内存消耗越高。

- 缓存穿透
查询不存在的数据时，数据库查询不到也不直接写入缓存，导致每次请求都查询数据库。
    - 缓存空数据
    - 布隆过滤器
        - 预热缓存时，同时预热布隆过滤器。
        - 访问缓存前，先经过布隆过滤器判断。
        - 实现复杂，存在误判

- 缓存击穿
当某一个缓存数据过期时，需要查询数据库，重建缓存。
在重建缓存期间，大量对该数据请求由于缓存未命中而直接访问数据库。
    - 互斥锁：强一致，性能差
        1. 查询缓存，若命中，则直接返回。
        2. 若未命中，先获取互斥锁，再查询数据库，重建缓存。
        3. 若获取锁失败，则重试第1步和第2步。
    - 逻辑过期：高可用，性能高
        0. 不设置过期时间，在缓存数据中设置逻辑过期时间。
        1. 查询缓存，若数据未过期，则直接返回。
        2. 若数据过期，先获取互斥锁，再开启一个用于查询数据库、重建缓存的新线程，最后直接返回旧缓存数据。
        3. 若获取锁失败，直接返回旧缓存数据。

- 缓存雪崩
同一时段大量的缓存数据同时失效或Redis服务宕机，导致大量请求访问数据库。
    - 给不同key的TTL添加随机值
    - 使用多级缓存
    - 使用Redis集群：哨兵模式、集群模式
    - 添加降级限流策略

- 双写一致性
当修改了数据库的数据后，也要同时更新缓存的数据，保持缓存和数据库的数据一致。
    - 延时双删
        - 写操作时，先删除缓存数据，再修改数据库，延时后删除缓存数据
        - 缺点：延时的时长难以控制。
    - 一致性要求高时
        - 使用redisson提供的读写锁
    - 允许延时一致时：采用异步通知
        - 使用MQ中间件，更新数据后，通知删除缓存。
        - 使用canal中间件，读取数据库的binlog，更新缓存。

- Redis持久化
    - RDB（Redis数据备份文件）：定时对内存进行快照
        执行原理：fork出一个子进程，子进程共享父进程的内存数据，读取数据并写入RDB文件。父进程修改时，进行写时复制。
        - 主动备份：save（主进程执行RDB）、bgsave（子进程执行RDB）
        - 被动触发：redis.conf中设置触发机制
    - AOF（追加文件）：记录每一次执行的写命令
        - redis.conf中设置触发机制
        - Always、everysec、no
        - 文件体积大、宕机恢复速度慢、数据完整性高
    - 混合持久化
        - AOF重写时会把Redis的持久化数据，以RDB的格式写入到AOF文件的开头，之后的数据再以AOF的格式化追加到文件的末尾。

- Redis数据删除策略
针对过期的数据
惰性删除和定期删除配合使用
    - 惰性删除
        - 使用时检测缓存是否过期，过期则删除。
    - 定期删除
        - SLOW模式：执行频率固定
        - FAST模式：执行频率不固定

- Redis数据淘汰策略
当内存不足时，执行数据淘汰策略。
    - noeviction（默认）：不淘汰数据，不允许写入新数据。
    - volatile-ttl：淘汰设置了TTL的键中的TTL值最小的数据。
    - allkeys-lru、allkeys-lfu、allkeys-random
    - volatile-lru、volatile-lfu、volatile-random

- 分布式锁
    - setnx命令`set lock 1 nx ex 10`
        - 设置过期时间，防止加锁期间系统宕机造成锁不释放。
        - 存在的问题：业务未完成而锁过期。
    - redisson分布式锁
        - 可重入
        - 提供看门狗机制
        - 不能解决主从一致性问题。
            - 可以使用redisson提供的红锁解决，但性能低。
            - 使用zookeeper实现的分布式锁。

- Redis集群方案——主从同步
解决高并发读问题
主节点有唯一的replid，从节点继承主节点的replid。
主节点负责写数据，从节点负责读数据。
    - 全量与增量
        1. 从节点建立连接，发送replid和offset，请求数据同步。
        2. 主节点判断是否为第一次同步（replid是否一致）。
        3. 若是，进行全量同步，否则进行增量同步。
    - 全量同步
        1. 主节点发送数据版本信息，从节点接受信息并保存。
        2. 主节点执行bgsave，生成RDB文件，并发送给从节点。
        3. 从节点清空数据，并加载RDB文件。
        4. 主节点将生成RDB期间的所有命令记录到repl_baklog中。
        5. 主节点将repl_baklog中的命令发送给从节点。
        6. 从节点执行repl_baklog中的命令。
    - 增量同步
        1. 主节点从repl_baklog获取offset后的数据，并发送给从节点。
        2. 从节点执行命令。

- Redis集群方案——哨兵模式
解决高可用问题
<!-- TODO -->
    - 监控
    - 自动故障恢复
    - 通知

- Redis集群方案——分片集群
解决海量数据存储和高并发写的问题
    - 使用多个主节点，保存不同的数据
    - 每个主节点有多个从节点
    - 主节点间使用心跳机制监测彼此监控
数据的读写
    - 16*1024个哈希槽
    - 每个主节点绑定一定范围的哈希槽
    - 读写数据时，将key的有效部分计算哈希值并取余，决定目标槽槽，进而确定目标节点。

- Redis是单线程的，但为什么还那么快？
<!-- TODO -->
    - 纯内存操作，执行速度快，性能瓶颈是网络延迟。
    - 单线程的优势：避免不必要的上下文切换和资源争用。
    - 使用IO多路复用模型，非阻塞IO。
        - 实现了高效的网络请求。
    - 高效的数据结构

- Redis基本数据类型
    - String
    - List
    - Hash
    - Set
    - ZSet

- Redis的底层数据结构
<!-- TODO -->

## Spring
- Spring中的Bean
Bean默认是单例的，不是线程安全的。
    - 一般情况下注入的Bean是无状态对象，没有线程安全问题。
    - 如果在Bean中定义了可修改的成员变量，则需要考虑线程安全问题。

- AOP（面向切面编程）
减少系统中的重复代码，降低模块间的耦合度，提高系统的可维护性。
    - 规则定义：@Pointcut
    - 逻辑执行：@Before、@After、@AfterReturning、@AfterThrowing、@Around

- Spring的事务
通过AOP功能，对方法前后进行拦截，在执行方法前开启事务，在执行方法后提交事务或回滚。
    - 编程式事务控制
    - 声明式事务管理

- Spring事务失效的场景
    - 异常捕获处理
        - 在方法内使用try-catch处理了异常而未将异常交给事务通知处理，导致事务失效。
    - 抛出检查异常
        - Spring默认回滚非检查异常。
        - 可通过rollbackFor属性指定回滚的异常类型。
    - 非public方法
        - Spring为方法创建代理、添加事务通知的前提是该方法是public的
    - 同一个类中的非事务方法调用事务方法

- Spring的Bean的生命周期
    1. 通过BeanDefinition获取Bean的定义信息。
    2. 构造函数
    3. 属性注入
    4. Aware接口的子接口方法
        - BeanNameAware
        - BeanFactoryAware
        - ApplicationContextAware
    5. 初始化方法
        1. BeanPostProcessor接口的预初始化函数
        2. @PostConstruct注解方法
        3. InitializingBean接口方法
        4. init-method
        5. BeanPostProcessor接口的后初始化函数
    6. 可使用
    7. 销毁方法
        1. @PreDestroy注解方法
        2. DisposableBean接口方法
        3. destroy-method

- Spring解决循环依赖
构造函数的循环依赖：使用@Lazy注解
三级缓存
    - 一级缓存：单例池，已经完成初始化的Bean对象
    - 二级缓存：缓存早期的Bean对象（尚未完成初始化）
    - 三级缓存：缓存ObjectFactory（用于创建对象的对象工厂）

- Springboot的自动配置原理
    - Springboot引导类上的@SpringBootApplication注解
        - @SpringBootConfiguration
        - @EnableAutoConfiguration
            - 使用@Import导入配置选择器
            - 读取项目和引用的jar包中的META-INF/spring.factories文件中
            - 根据条件注解所指定的条件决定是否将Bean导入到Spring容器中。
        - @ComponentScan

- Mybatis的缓存
基于perpetualCache的HashMap本地缓存。但当作用域进行增删改后，会清空该作用域的全部缓存。
    - 一级缓存（默认开启）
        - 作用域为Session
        - 当Session进行flush或close时，会清除缓存。
    - 二级缓存
        - 作用域为namespace和mapper
        - 当Session进行flush或close时，一级缓存转到二级缓存中。

## JVM
- Java堆
线程共享区域，主要用来保存对象和数组。
    - 年轻代
    - 老年代
jdk1.7的堆区有一个永久代，存储的是类信息、静态变量、常量、编译后的代码。
jdk1.8 移除了永久代，改用本地内存区的元空间，防止内存溢出。

- 虚拟机栈
每个线程运行时所需要的内存。默认栈内存为1M。
方法内的局部变量是线程安全的。

- 方法区
方法区是各个线程共享的内存区域，存储的是类信息、运行时常量池。
虚拟机启动时创建，关闭时释放。
    - 常量池：类名、方法名、参数类型、字面量等
    - 运行时常量池：当类被加载时，常量池信息会被放入运行时常量池中。，并将符号地址变为内存地址。

- 直接内存
不属于JVM的内存，不由JVM管理，是虚拟机的系统内存。
常见于NIO操作时，用于数据缓冲区。

- 类加载器
将字节码文件加载到JVM中。
    - 启动类加载器：加载jre/lib下的库
    - 扩展类加载器：加载jre/lib/ext下的类
    - 应用类加载器：加载classpath下的类
    - 自定义类加载器

- 双亲委派模型
    - 加载类时，先委托上级加载器加载，如果找不到，则由子加载器加载。
    - 避免类被重复加载，保证类库API不会被修改。

- 类装载的执行过程
    - 加载：将字节码文件加载到JVM中。
    - 验证：验证字节码文件的正确性。
    - 准备：为类变量分配内存，并赋予初始值。
    - 解析：将符号引用转换为直接引用。
    - 初始化：执行类的静态代码块和静态变量的初始化。
    - 使用：JVM从入口方法中开始执行。
    - 卸载：当类不再被使用时，卸载掉。

- 垃圾回收
    - 引用计数法
    - 可达性分析：沿`GC Root`对象为起点的引用链找不到的对象则可以被回收。
        - 虚拟机栈中引用的对象
        - 类静态属性引用的对象
        - 常量引用的对象
        - JNI

- 垃圾回收算法
    - 标记清除算法
        - 标记存活对象，清除无用对象。
        - 效率高，内存碎片多。
    - 标记整理算法
        - 对象需要移动，效率低
    - 复制算法
        - 两块内存，每次只使用其中一块。
        - 内存利用率低

- 分代回收
    年轻代和老年代
        - 年轻代：三分之一
            - Eden：0.8
            - from：0.1
            - to：0.2
        - 老年代：三分之二
    工作机制
        - 新创建的对象放到Eden中。
        - Eden区内存不足时，标记Eden和from中的存活对象，将其移动到to，然后释放Eden和from区。
        - 幸存对象经过多次回收（最多15次）后，移到老年代区。
        - 幸存区内存不足或大对象，会提前移到老年代区。
    GC
        - MinorGC（youngGC）：仅新生代，暂停时间短
        - MixedGC：新生代和部分老年代，G1收集器特有
        - FullGC：全部新生代和老年代，暂停时间长

- 垃圾回收器
    - 串行垃圾收集器：只有一个线程工作，适合堆内存小的情况
        - Serial：采用复制算法，作用于新生代
        - SerialOld：采用标记整理算法，作用于老年代
    - 并行垃圾收集器（jdk8默认）：多个线程共同工作
        - ParNew：采用复制算法，作用于新生代
        - ParallelOld：采用标记整理算法，作用于老年代
    - CMS（并发）垃圾收集器：采用标记清除算法，针对老年代
    - G1垃圾收集器

- G1垃圾收集器（jdk9后默认）
<!-- TODO -->
划分为多个区域，每个区域都可充当Eden、Survivor、Old、humongous（为大对象准备）
采用复制算法，分三个阶段
    - 新生代回收
    - 并发标记
    - 混合收集





## 分布式
### Paxos算法




